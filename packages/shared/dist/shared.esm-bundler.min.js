function t(t,e,l=100,i=[],o=0){const r=t+e+l,s=n(t-l,i),u=n(r,i);return[Math.max(0,s-o),Math.min(i.length-1,u+o)]}function n(t,n){let e=0,l=n.length-1,i=n.length;for(;e<=l;){const o=Math.floor((e+l)/2);n[o].y>=t?(i=o,l=o-1):e=o+1}return i}function e(t,n){new IntersectionObserver((([e],l)=>{e.isIntersecting?(t.firstElementChild&&t.firstElementChild.classList.add(n),l.unobserve(t)):t.firstElementChild&&t.firstElementChild.classList.remove(n)}),{root:this.el,threshold:.1}).observe(t)}function l(t,n,e=!1){let l=null,i=!1;return function(...o){const r=this;!e||l||i||(t.apply(r,o),i=!0),null!==l&&clearTimeout(l),l=setTimeout((()=>{e||t.apply(r,o),l=null,i=!1}),n)}}function i(t,n,e={}){let l,i,o=null,r=0;const s=()=>{r=!1===e.leading?0:Date.now(),o=null,t.apply(l,i),l=i=null},u=function(...u){const c=Date.now();r||!1!==e.leading||(r=c);const a=n-(c-r);l=this,i=u,a<=0||a>n?(o&&(clearTimeout(o),o=null),r=c,t.apply(l,i),l=i=null):o||!1===e.trailing||(o=setTimeout(s,a))};return u.cancel=()=>{clearTimeout(o),o=null,r=0},u}export{t as _getVisibleRange,l as debounce,e as observeVisibility,i as throttle};
