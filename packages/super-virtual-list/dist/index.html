<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        * {
            padding: 0;
            margin: 0;
        }

        .waterfall-item {
            overflow-wrap: break-word;
            word-break: normal;
        }

        .fade-in {
            animation: .4s imgAnime ease;
        }

        @keyframes imgAnime {
            0% {
                opacity: 0;
                transform: translateY(200px);
            }

            100% {
                opacity: 1;
                transform: translateY(0);
            }
        }
    </style>
</head>

<body>
    <div id="waterfall-container">
    </div>
    <script type="module">
        import { SuperVirtual } from './super-virtual-list.js'
        import { mockData } from './mock.js'
        let limit = 18;
        let page = 0;
        const getData = async () => {
            let result = await request(`https://www.vilipix.com/api/v1/picture/public?limit=${limit}&sort=hot&offset=${limit * page
                }`)
            if (result.code == 0) {
                page++;
            }
            return result.data.rows;
        }



        window.virtual = new SuperVirtual({
            el: document.querySelector('#waterfall-container'),
            viewportHeight: 800,
            data: getData,
            animeClass: 'fade-in',
            column: 4,
            gap: 20,
            renderItem: (item) => {
                const div = document.createElement('div');
                div.className = 'waterfall-item';
                div.innerHTML = `
                    <div>
                        <img src="${item.original_url}" style="width: 100%;">
                        <p style="padding: 4px;">#${item.tags}</p>
                    </div
                `;
                return div;
            },
            scrollToBottom: getData
        });
        console.log(window.virtual)



        function request(url, options = {}) {
            return new Promise((resolve, reject) => {
                fetch(url, options)
                    .then(async (response) => {
                        if (!response.ok) {
                            const errorText = await response.text();
                            reject(new Error(`HTTP error! status: ${response.status}, message: ${errorText}`));
                        } else {
                            // 尝试解析为 JSON，失败则返回原始文本
                            try {
                                const data = await response.json();
                                resolve(data);
                            } catch (e) {
                                const text = await response.text();
                                resolve(text);
                            }
                        }
                    })
                    .catch((error) => {
                        reject(new Error(`Network error: ${error.message}`));
                    });
            });
        }

    </script>
</body>

</html>